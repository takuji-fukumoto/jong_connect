create table "public"."joined_group_match_players" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "group_match_id" bigint,
    "user_id" uuid
);


alter table "public"."joined_group_match_players" enable row level security;

CREATE UNIQUE INDEX joined_group_match_players_pkey ON public.joined_group_match_players USING btree (id);

alter table "public"."joined_group_match_players" add constraint "joined_group_match_players_pkey" PRIMARY KEY using index "joined_group_match_players_pkey";

alter table "public"."joined_group_match_players" add constraint "joined_group_match_players_group_match_id_fkey" FOREIGN KEY (group_match_id) REFERENCES group_matches(id) ON DELETE CASCADE not valid;

alter table "public"."joined_group_match_players" validate constraint "joined_group_match_players_group_match_id_fkey";

alter table "public"."joined_group_match_players" add constraint "joined_group_match_players_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."joined_group_match_players" validate constraint "joined_group_match_players_user_id_fkey";

grant delete on table "public"."joined_group_match_players" to "anon";

grant insert on table "public"."joined_group_match_players" to "anon";

grant references on table "public"."joined_group_match_players" to "anon";

grant select on table "public"."joined_group_match_players" to "anon";

grant trigger on table "public"."joined_group_match_players" to "anon";

grant truncate on table "public"."joined_group_match_players" to "anon";

grant update on table "public"."joined_group_match_players" to "anon";

grant delete on table "public"."joined_group_match_players" to "authenticated";

grant insert on table "public"."joined_group_match_players" to "authenticated";

grant references on table "public"."joined_group_match_players" to "authenticated";

grant select on table "public"."joined_group_match_players" to "authenticated";

grant trigger on table "public"."joined_group_match_players" to "authenticated";

grant truncate on table "public"."joined_group_match_players" to "authenticated";

grant update on table "public"."joined_group_match_players" to "authenticated";

grant delete on table "public"."joined_group_match_players" to "service_role";

grant insert on table "public"."joined_group_match_players" to "service_role";

grant references on table "public"."joined_group_match_players" to "service_role";

grant select on table "public"."joined_group_match_players" to "service_role";

grant trigger on table "public"."joined_group_match_players" to "service_role";

grant truncate on table "public"."joined_group_match_players" to "service_role";

grant update on table "public"."joined_group_match_players" to "service_role";

ALTER TABLE ONLY "public"."joined_group_match_players"
    ADD CONSTRAINT "joined_group_match_players_group_match_id_and_user_id_key" UNIQUE ("group_match_id", "user_id");

create or replace function is_joinned_group_from_match(group_match_id bigint) returns boolean 
  language sql security definer
as $$
  select exists(
    select groups.id
    from public.groups
    inner join public.user_joinned_groups 
        on (groups.id = user_joinned_groups.group_id and user_joinned_groups.user_id = auth.uid())
    inner join public.group_matches
        on (groups.id = group_matches.group_id and group_matches.id = is_joinned_group_from_match.group_match_id)
  );
$$;

create policy "Users can view joined_group_match_players that they have joined"
  on public.joined_group_match_players for select using (is_joinned_group_from_match(group_match_id));

create policy "Users can create joined_group_match_players that they have joined"
  on public.joined_group_match_players for insert with check  (is_joinned_group_from_match(group_match_id));

create policy "Users can update joined_group_match_players that they have joined"
  on public.joined_group_match_players for update using (is_joinned_group_from_match(group_match_id)) with check (is_joinned_group_from_match(group_match_id));

create policy "Users can delete joined_group_match_players that they have joined"
  on public.joined_group_match_players for delete using (is_joinned_group_from_match(group_match_id));

-- グループマッチ参加者変更用
CREATE OR REPLACE FUNCTION "public"."edit_group_match_players"(group_match_id bigint, join_player_ids uuid[]) RETURNS void
  LANGUAGE "plpgsql" SECURITY INVOKER
  AS $$
begin
  if array_length(edit_group_match_players.join_player_ids, 1) = 0 then
    raise exception 'join_player_ids should not be Empty';
  end if;

  -- 対象に入っていないプレイヤーを削除
  delete from joined_group_match_players
  where group_match_id = edit_group_match_players.group_match_id and user_id > ALL(edit_group_match_players.join_player_ids);

  -- 対象プレイヤーをupsert
  insert into joined_group_match_players (user_id, group_match_id)
  select unnest(edit_group_match_players.join_player_ids), edit_group_match_players.group_match_id
  on conflict (user_id, group_match_id)
  do nothing;
end
$$;
